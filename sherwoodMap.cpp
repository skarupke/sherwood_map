//#define PROFILE_SHERWOOD_MAP
#include "sherwoodMap.hpp"
#include <stdexcept>

namespace detail
{
#ifdef PROFILE_SHERWOOD_MAP
size_t profile_cost = 0;
#endif
void throw_sherwood_map_out_of_range()
{
	throw std::out_of_range("out of range when trying to access a sherwood_map");
}

// prime numbers generated by the following method:
// 1. start with a prime p = 2
// 2. go to wolfram alpha and get p = NextPrime(2 * p)
// 3. repeat 2. until you overflow 64 bits
// you now have large gaps which you would hit if somebody called reserve() with an unlucky number.
// 4. to fill the gaps for every prime p go to wolfram alpha and get ClosestPrime(p * 2^(1/3)) and ClosestPrime(p * 2^(2/3)) and put those in the gaps
// 5. get PrevPrime(2^64) and put it at the end
#ifdef PROFILE_SHERWOOD_MAP
static std::vector<size_t> prime_list =
#else
static constexpr const size_t prime_list[] =
#endif
{
	2llu, 3llu, 5llu, 7llu, 11llu, 13llu, 17llu, 23llu, 29llu, 37llu, 47llu,
	59llu, 73llu, 97llu, 127llu, 151llu, 197llu, 251llu, 313llu, 397llu,
	499llu, 631llu, 797llu, 1009llu, 1259llu, 1597llu, 2011llu, 2539llu,
	3203llu, 4027llu, 5087llu, 6421llu, 8089llu, 10193llu, 12853llu, 16193llu,
	20399llu, 25717llu, 32401llu, 40823llu, 51437llu, 64811llu, 81649llu,
	102877llu, 129607llu, 163307llu, 205759llu, 259229llu, 326617llu,
	411527llu, 518509llu, 653267llu, 823117llu, 1037059llu, 1306601llu,
	1646237llu, 2074129llu, 2613229llu, 3292489llu, 4148279llu, 5226491llu,
	6584983llu, 8296553llu, 10453007llu, 13169977llu, 16593127llu, 20906033llu,
	26339969llu, 33186281llu, 41812097llu, 52679969llu, 66372617llu,
	83624237llu, 105359939llu, 132745199llu, 167248483llu, 210719881llu,
	265490441llu, 334496971llu, 421439783llu, 530980861llu, 668993977llu,
	842879579llu, 1061961721llu, 1337987929llu, 1685759167llu, 2123923447llu,
	2675975881llu, 3371518343llu, 4247846927llu, 5351951779llu, 6743036717llu,
	8495693897llu, 10703903591llu, 13486073473llu, 16991387857llu,
	21407807219llu, 26972146961llu, 33982775741llu, 42815614441llu,
	53944293929llu, 67965551447llu, 85631228929llu, 107888587883llu,
	135931102921llu, 171262457903llu, 215777175787llu, 271862205833llu,
	342524915839llu, 431554351609llu, 543724411781llu, 685049831731llu,
	863108703229llu, 1087448823553llu, 1370099663459llu, 1726217406467llu,
	2174897647073llu, 2740199326961llu, 3452434812973llu, 4349795294267llu,
	5480398654009llu, 6904869625999llu, 8699590588571llu, 10960797308051llu,
	13809739252051llu, 17399181177241llu, 21921594616111llu, 27619478504183llu,
	34798362354533llu, 43843189232363llu, 55238957008387llu, 69596724709081llu,
	87686378464759llu, 110477914016779llu, 139193449418173llu,
	175372756929481llu, 220955828033581llu, 278386898836457llu,
	350745513859007llu, 441911656067171llu, 556773797672909llu,
	701491027718027llu, 883823312134381llu, 1113547595345903llu,
	1402982055436147llu, 1767646624268779llu, 2227095190691797llu,
	2805964110872297llu, 3535293248537579llu, 4454190381383713llu,
	5611928221744609llu, 7070586497075177llu, 8908380762767489llu,
	11223856443489329llu, 14141172994150357llu, 17816761525534927llu,
	22447712886978529llu, 28282345988300791llu, 35633523051069991llu,
	44895425773957261llu, 56564691976601587llu, 71267046102139967llu,
	89790851547914507llu, 113129383953203213llu, 142534092204280003llu,
	179581703095829107llu, 226258767906406483llu, 285068184408560057llu,
	359163406191658253llu, 452517535812813007llu, 570136368817120201llu,
	718326812383316683llu, 905035071625626043llu, 1140272737634240411llu,
	1436653624766633509llu, 1810070143251252131llu, 2280545475268481167llu,
	2873307249533267101llu, 3620140286502504283llu, 4561090950536962147llu,
	5746614499066534157llu, 7240280573005008577llu, 9122181901073924329llu,
	11493228998133068689llu, 14480561146010017169llu, 18446744073709551557llu
};
size_t next_prime(size_t size)
{
	auto small_end = std::begin(prime_list) + 8;
	auto result = std::lower_bound(std::begin(prime_list), small_end, size);
	if (result == small_end) return *std::lower_bound(small_end, std::end(prime_list), size);
	else return *result;
}
}

#ifndef DISABLE_GTEST
#include <gtest/gtest.h>
static_assert(std::is_nothrow_move_constructible<sherwood_map<int, int> >::value, "expect it to be nothrow movable");
static_assert(std::is_nothrow_move_assignable<sherwood_map<int, int> >::value, "expect it to be nothrow movable");
namespace
{
struct IdentityHasher
{
	template<typename T>
	size_t operator()(T value) const
	{
		return value;
	}
};

TEST(sherwood_map, empty)
{
	sherwood_map<int, int> a;
	ASSERT_EQ(a.end(), a.find(5));
	ASSERT_TRUE(a.empty());
	a.emplace();
	a.clear();
	ASSERT_TRUE(a.empty());
}

TEST(sherwood_map, simple)
{
	sherwood_map<int, int> a = { { 1, 5 }, { 2, 6 }, { 3, 7 } };
	ASSERT_EQ(3, a.size());
	a.insert(std::make_pair(1, 6));
	ASSERT_EQ(3, a.size());
	ASSERT_EQ(5, a[1]);
	ASSERT_EQ(6, a[2]);
	ASSERT_EQ(7, a[3]);
	ASSERT_EQ(0, a[4]);
	ASSERT_EQ(4, a.size());
	auto found = a.find(3);
	ASSERT_NE(a.end(), found);
	ASSERT_EQ(3, found->first);
	ASSERT_EQ(7, found->second);
	ASSERT_EQ(a.end(), a.find(5));

	ASSERT_EQ((sherwood_map<int, int>{ { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 0 } }), a);
}
TEST(sherwood_map, move_construct)
{
	sherwood_map<std::string, std::unique_ptr<int> > a;
	a["foo"] = std::unique_ptr<int>(new int(5));
	ASSERT_EQ(5, *a["foo"]);
	float load_factor = a.max_load_factor() / 2;
	a.max_load_factor(load_factor);
	std::pair<std::string, std::unique_ptr<int> > to_insert("foo", std::unique_ptr<int>(new int(6)));
	a.emplace(std::move(to_insert));
	sherwood_map<std::string, std::unique_ptr<int> > b(std::move(a));
	ASSERT_EQ(1, b.size());
	ASSERT_EQ(0, a.size());
	ASSERT_EQ(5, *b["foo"]);
	ASSERT_EQ(load_factor, b.max_load_factor());
}
TEST(sherwood_map, copy)
{
	sherwood_map<int, int> a{ { 1, 2 }, { 3, 4 }, { 5, 6 } };
	a.max_load_factor(a.max_load_factor() / 2);
	sherwood_map<int, int> b(a);
	ASSERT_EQ(a, b);
	ASSERT_EQ(a.max_load_factor(), b.max_load_factor());
}
TEST(sherwood_map, erase)
{
	sherwood_map<int, int> a = { { 1, 2 }, { 3, 4 } };
	ASSERT_EQ(2, a.size());
	ASSERT_EQ(1, a.erase(3));
	ASSERT_EQ(1, a.size());
	ASSERT_EQ((sherwood_map<int, int>{ { 1, 2 } }), a);
}
TEST(sherwood_map, iterator_erase)
{
	sherwood_map<int, int> a = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
	auto begin = a.erase(a.begin(), std::next(a.begin(), 2));
	ASSERT_EQ(a.begin(), begin);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	ASSERT_TRUE(a.empty());
}
TEST(sherwood_map, conflicting_iterator_erase)
{
	sherwood_map<int, int, IdentityHasher> a;
	a.max_load_factor(1.0f);
	a.reserve(5);
	a.insert({ { 1, 2 }, { 6, 5 }, { 11, 8 }, { 16, 11 } });
	auto begin = a.erase(a.begin(), std::next(a.begin(), 2));
	ASSERT_EQ(a.begin(), begin);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	ASSERT_TRUE(a.empty());
}
TEST(sherwood_map, range_erase)
{
	sherwood_map<int, int> a{ { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 0 } };
	a.erase(std::next(a.begin()), a.end());
	ASSERT_EQ(1, a.size());
	a.erase(a.begin(), a.end());
	ASSERT_TRUE(a.empty());
}
TEST(sherwood_map, move_over_please)
{
	sherwood_map<int, int, IdentityHasher> a;
	a.max_load_factor(1.0f);
	a.rehash(5);
	// the idea is this: 1 and 2 go to their spots. 5 goes to 0,
	// 10 can't go to 0 so goes to 1 and pushes 1 and 2 over,
	// 15 does the same thing
	a.insert({ { 1, 5 }, { 2, 6 }, { 5, 7 }, { 10, 8 }, { 15, 9 } });
	ASSERT_EQ((sherwood_map<int, int, IdentityHasher>{ { 1, 5 }, { 2, 6 }, { 5, 7 }, { 10, 8 }, { 15, 9 } }), a);
}
TEST(sherwood_map, emplace_hint)
{
	sherwood_map<int, int> a = { { 1, 2 }, { 3, 4 } };
	auto found = a.find(1);
	ASSERT_NE(a.end(), found);
	auto insert_point = a.erase(found);
	a.insert(insert_point, std::make_pair(1, 3));
	ASSERT_EQ((sherwood_map<int, int>{ { 1, 3 }, { 3, 4 } }), a);
}

TEST(sherwood_map, special_value)
{
	size_t special_value = 0;
	sherwood_map<size_t, int, IdentityHasher> a = { { special_value, 1 }, { special_value + 1, 2 } };
	ASSERT_EQ(2, a.size());
	ASSERT_EQ(1, a[special_value]);
	ASSERT_EQ(2, a[special_value + 1]);
}
TEST(sherwood_map, crowded_end)
{
	// test whether erase will correctly shift elements from the beginning
	// of the storage to the end of the storage when erasing near the end
	sherwood_map<int, int, IdentityHasher> a;
	a.rehash(31);
	ASSERT_EQ(31, a.bucket_count()); // need to be my amount for this test to make sense
	a[28] = 5;
	a[59] = 6;
	a[90] = 7;
	a[121] = 8;
	a[152] = 9;
	a[183] = 10;
	a[214] = 11;
	ASSERT_EQ(31, a.bucket_count()); // reallocation would mess up my test
	ASSERT_EQ(121, a.begin()->first); // assume 28 goes to 28, 59 goes to 29, 90 goes to 30, 121 goes to 0
	ASSERT_EQ((sherwood_map<int, int, IdentityHasher>{ { 28, 5 }, { 59, 6 }, { 90, 7 }, { 121, 8 }, { 152, 9, }, { 183, 10 }, { 214, 11 } }), a);
	a.erase(28);
	ASSERT_EQ((sherwood_map<int, int, IdentityHasher>{ { 59, 6 }, { 90, 7 }, { 121, 8 }, { 152, 9, }, { 183, 10 }, { 214, 11 } }), a);
	// had a bug where elements remained and weren't markes as deleted properly
	ASSERT_EQ(a.size(), std::distance(a.begin(), a.end()));
}
TEST(sherwood_map, swap)
{
	sherwood_map<int, int> a = { { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 } };
	a.max_load_factor(0.5f);
	sherwood_map<int, int> b = { { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 } };
	b.max_load_factor(0.6f);
	a.swap(b);
	ASSERT_EQ((sherwood_map<int, int>{ { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 } }), b);
	ASSERT_EQ(5, b.size());
	ASSERT_EQ(0.5f, b.max_load_factor());
	ASSERT_EQ((sherwood_map<int, int>{ { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 } }), a);
	ASSERT_EQ(6, a.size());
	ASSERT_EQ(0.6f, a.max_load_factor());
}
struct CtorDtorCounter
{
	CtorDtorCounter(int & ctor_counter, int & dtor_counter)
		: ctor_counter(ctor_counter), dtor_counter(dtor_counter)
	{
		++ctor_counter;
	}
	CtorDtorCounter(const CtorDtorCounter & other)
		: ctor_counter(other.ctor_counter), dtor_counter(other.dtor_counter)
	{
		++ctor_counter;
	}
	CtorDtorCounter & operator=(const CtorDtorCounter &)
	{
		return *this;
	}
	~CtorDtorCounter()
	{
		++dtor_counter;
	}

private:
	int & ctor_counter;
	int & dtor_counter;
};
static size_t construction_counter = 0;
static size_t destruction_counter = 0;
static size_t num_allocations = 0;
static size_t num_frees = 0;
template<typename T>
struct CountingAllocator
{
	CountingAllocator() = default;
	template<typename U>
	CountingAllocator(CountingAllocator<U>)
	{
	}

	typedef T value_type;
	template<typename U>
	struct rebind
	{
		typedef CountingAllocator<U> other;
	};

	T * allocate(size_t n, const void * = nullptr)
	{
		++num_allocations;
		return static_cast<T *>(malloc(sizeof(T) * n));
	}
	void deallocate(T * ptr, size_t)
	{
		++num_frees;
		return free(ptr);
	}
	template<typename U, typename... Args>
	void construct(U * ptr, Args &&... args)
	{
		new (ptr) U(std::forward<Args>(args)...);
		++construction_counter;
	}
	template<typename U>
	void destroy(U * ptr)
	{
		++destruction_counter;
		ptr->~U();
	}
};
template<typename K, typename V, typename Hash = std::hash<K>, typename Equal = std::equal_to<K> >
using counting_sherwood_map = sherwood_map<K, V, Hash, Equal, CountingAllocator<std::pair<const K, V> > >;
struct ScopedAssertNoLeaks
{
	ScopedAssertNoLeaks(bool expect_allocations, bool expect_constructions)
		: expect_allocations(expect_allocations)
		, expect_constructions(expect_constructions)
		, constructions_before(construction_counter)
		, destructions_before(destruction_counter)
		, allocations_before(num_allocations)
		, frees_before(num_frees)
	{
	}
	~ScopedAssertNoLeaks()
	{
		run_asserts();
	}

private:
	bool expect_allocations;
	bool expect_constructions;
	size_t constructions_before;
	size_t destructions_before;
	size_t allocations_before;
	size_t frees_before;

	void run_asserts()
	{
		if (expect_allocations)
		{
			ASSERT_NE(num_allocations, allocations_before);
		}
		if (expect_constructions)
		{
			ASSERT_NE(construction_counter, constructions_before);
		}
		ASSERT_EQ(construction_counter - constructions_before, destruction_counter - destructions_before);
		ASSERT_EQ(num_allocations - allocations_before, num_frees - frees_before);
	}
};

TEST(sherwood_map, destructor_caller)
{
	ScopedAssertNoLeaks leak_check(true, true);
	int ctor_counter = 0;
	int dtor_counter = 0;
	{
		counting_sherwood_map<int, CtorDtorCounter> a;
		for (int i = 0; i < 10; ++i)
		{
			a.emplace(i, CtorDtorCounter(ctor_counter, dtor_counter));
		}
		a.erase(5);
		a.erase(a.begin(), std::next(a.begin(), 3));
	}
	ASSERT_NE(0, ctor_counter);
	ASSERT_EQ(ctor_counter, dtor_counter);
}
struct throwing_allocator_exception {};
template<typename T>
struct throwing_allocator : CountingAllocator<T>
{
	throwing_allocator() = default;
	template<typename U>
	throwing_allocator(const throwing_allocator<U> &)
	{
	}

	template<typename U>
	struct rebind
	{
		typedef throwing_allocator<U> other;
	};

	template<typename U, typename... Args>
	void construct(U *, Args &&...)
	{
		throw throwing_allocator_exception{};
	}
};

TEST(sherwood_map, throwing_allocator)
{
	ScopedAssertNoLeaks leak_check(true, false);
	auto construct = []{ sherwood_map<int, int, std::hash<int>, std::equal_to<int>, throwing_allocator<std::pair<const int, int> > >{ { 1, 2 }, { 2, 3 } }; };
	ASSERT_THROW(construct(), throwing_allocator_exception);
}

struct stateful_hasher
{
	stateful_hasher() = default;
	stateful_hasher(const stateful_hasher & other)
		: to_add(other.to_add + 1)
	{
	}
	stateful_hasher(stateful_hasher &&) = default;
	stateful_hasher & operator=(const stateful_hasher & other)
	{
		to_add = other.to_add + 1;
		return *this;
	}
	stateful_hasher & operator=(stateful_hasher &&) = default;

	template<typename T>
	size_t operator()(const T & value) const
	{
		return std::hash<T>()(value) + to_add;
	}

	size_t to_add = 0;
};

TEST(sherwood_map, stateful_hasher)
{
	sherwood_map<int, int, stateful_hasher> a{ { 1, 2 }, { 3, 4 }, { 5, 7 }, { 8, 9 } };
	a = a;
	ASSERT_EQ((sherwood_map<int, int, stateful_hasher>{ { 1, 2 }, { 3, 4 }, { 5, 7 }, { 8, 9 } }), a);
}

TEST(sherwood_map, load_factor)
{
	sherwood_map<int, int> a;
	ASSERT_EQ(0, a.load_factor());
}
TEST(sherwood_map, max_load_factor)
{
	sherwood_map<int, int> a;
	a.max_load_factor(1.0f);
	a.insert({ { 1, 2 }, { 2, 3 }, { 3, 4 } });
	ASSERT_EQ((sherwood_map<int, int>{ { 1, 2 }, { 2, 3 }, { 3, 4 } }), a);
}
TEST(sherwood_map, dont_grow_when_you_wont_insert)
{
	sherwood_map<int, int> a;
	a.max_load_factor(1.0f);
	a.reserve(3);
	size_t bucket_count_before = a.bucket_count();
	a.insert({ { 1, 2 }, { 3, 4 }, { 5, 6 }, { 5, 6 } });
	ASSERT_EQ(bucket_count_before, a.bucket_count());
}
TEST(sherwood_map, allow_growing_with_max_load_factor_1)
{
	sherwood_map<int, int, IdentityHasher> a;
	a.max_load_factor(1.0f);
	a.reserve(3);
	a.insert({ { 1, 2 }, { 4, 4 }, { 7, 6 }, { 10, 8 } });
	ASSERT_EQ((sherwood_map<int, int, IdentityHasher>{ { 1, 2 }, { 4, 4 }, { 7, 6 }, { 10, 8 } }), a);
}

}
#include <random>
#include <unordered_map>
#include <map>
namespace
{
template<typename T>
T test_performance(int amount, int seed, float load_factor = T().max_load_factor())
{
	T hash_map;
	hash_map.max_load_factor(load_factor);
	//hash_map.rehash(seed);
	std::mt19937 engine(seed/* + amount + seed_modifier*/);
	std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
	std::vector<int> all_keys;
	all_keys.reserve(amount);
	for (int i = 0; i < int(all_keys.capacity()); ++i)
	{
		all_keys.push_back(distribution(engine));
		hash_map[all_keys.back()] = i;
	}
	for (size_t i = 0; i < all_keys.capacity() / 2; ++i)
	{
		auto found = hash_map.find(all_keys[distribution(engine) % all_keys.size()]);
		if (found != hash_map.end()) hash_map.erase(found);
		hash_map[distribution(engine)] = distribution(engine);
	}
	return hash_map;
}
constexpr int profile_amount = 1000000;
struct LargeStruct
{
	LargeStruct()
		: a(0)
	{
	}
	LargeStruct(int a)
		: a(a)
	{
	}
	int a;
	char unused[1024];
};

TEST(sherwood_map, profile_sherwood_map_small)
{
	test_performance<sherwood_map<int, int> >(profile_amount, 5);
}
TEST(sherwood_map, profile_unordered_map_small)
{
	test_performance<std::unordered_map<int, int> >(profile_amount, 5);
}
TEST(sherwood_map, profile_sherwood_map_large)
{
	test_performance<sherwood_map<int, LargeStruct> >(profile_amount, 5);
}
TEST(sherwood_map, profile_unordered_map_large)
{
	test_performance<std::unordered_map<int, LargeStruct> >(profile_amount, 5);
}

#ifdef PROFILE_SHERWOOD_MAP
TEST(sherwood_map, profile_first_insert)
{
	for (int i = 0; i < 1000000; ++i)
	{
		sherwood_map<int, int> a;
		a.emplace(1, 1);
	}
}
int seed_modifier = 11;
template<typename T>
T test_performance(int amount, int seed, float load_factor)
{
	T hash_map;
	hash_map.max_load_factor(load_factor);
	hash_map.rehash(seed);
	std::mt19937 engine(seed + amount + seed_modifier);
	std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
	std::vector<int> all_keys;
	all_keys.reserve(amount);
	for (int i = 0; i < int(all_keys.capacity()); ++i)
	{
		all_keys.push_back(distribution(engine));
		hash_map[all_keys.back()] = i;
	}
	for (size_t i = 0; i < all_keys.capacity() / 2; ++i)
	{
		auto found = hash_map.find(all_keys[distribution(engine) % all_keys.size()]);
		if (found != hash_map.end()) hash_map.erase(found);
		hash_map[distribution(engine)] = distribution(engine);
	}
	return hash_map;
}

const std::unordered_map<int, int> & build_control(int amount, int seed)
{
	static const float default_load_factor = std::unordered_map<int, int>().max_load_factor();
	static std::map<std::pair<int, int>, std::pair<int, std::unordered_map<int, int> > > controls;
	std::pair<int, int> key(amount, seed_modifier);
	auto found = controls.find(key);
	if (found != controls.end() && found->second.first == seed) return found->second.second;
	else return (controls[key] = std::make_pair(seed, test_performance<std::unordered_map<int, int> >(amount, seed, default_load_factor))).second;
}

double run_performance_test(int amount, int seed, float load_factor)
{
	Measurer measurer;
	detail::profile_cost = 0;
	sherwood_map<int, int> a = test_performance<sherwood_map<int, int> >(amount, seed, load_factor);
	size_t result = detail::profile_cost + 32 * measurer.GetNumAllocations();
	const std::unordered_map<int, int> & b = build_control(amount, seed);
	DE_ASSERT(a.size() == b.size());
	DE_ASSERT(std::all_of(b.begin(), b.end(), [&a](const auto & value)
	{
		auto found = a.find(value.first);
		return a.end() != found && found->second == value.second;
	}));
	return result / double(amount);
}

struct CostMap
{
	void add_cost(int/* amount*/, int/* seed*/, double cost)
	{
		sum_cost += cost - 1;
	}

	double total_cost() const
	{
		return sum_cost;// / num_costs;
	}

private:
	double sum_cost = 0;
};

std::map<size_t, CostMap> costs;

int minimize_num_iterations(int amount, int seed, float load_factor)
{
	double baseline = run_performance_test(amount, seed, load_factor);
	size_t limit = *std::lower_bound(detail::prime_list.begin(), detail::prime_list.end(), std::ceil(amount / sherwood_map<int, int>().max_load_factor()));
	size_t min_index = 0;
	double min_cost = std::numeric_limits<double>::max();
	for (size_t i = 0; i < detail::prime_list.size(); ++i)
	{
		std::vector<size_t> before = detail::prime_list;
		auto to_erase = detail::prime_list.begin() + i;
		size_t erased = *to_erase;
		if (erased <= size_t(seed))
			continue;
		if (erased > limit)
			break;
		detail::prime_list.erase(to_erase);
		double cost = run_performance_test(amount, seed, load_factor);
		costs[erased].add_cost(amount, seed, cost / baseline);
		if (cost < min_cost)
		{
			min_index = i;
			min_cost = cost;
			//std::cout << amount << ": " << i << " (" << before[i] << "), " << cost << '\n';
		}
		detail::prime_list = std::move(before);
	}
	return min_index;
}

TEST(sherwood_map, performance)
{
	{
		std::map<float, double> load_factor_costs;
		for (float load_factor = 0.7f;; load_factor = std::min(1.0f, load_factor + 0.01f))
		{
			int limit = 1000;
			ScopedMeasurer measure("load_factor");
			size_t allocated_before = mem::MemoryManager::GetTotalBytesAllocated();
			double total_cost = 0.0;
			for (int starting_value = 0; starting_value < 3; starting_value += 2)
			{
				for (int i = 2; i < limit; i = i * 3 / 2)
				{
					total_cost += run_performance_test(i, starting_value, load_factor);
				}
			}
			load_factor_costs[load_factor] = total_cost;
			std::cout << load_factor << ": " << (mem::MemoryManager::GetTotalBytesAllocated() - allocated_before) << ", " << total_cost << ", ";
			if (load_factor == 1.0f)
				break;
		}
		std::map<size_t, float> sorted_load_factor_costs;
		for (const auto & pair : load_factor_costs)
		{
			sorted_load_factor_costs[pair.second] = pair.first;
		}
		for (const auto & pair : sorted_load_factor_costs)
		{
			std::cout << pair.first << ": " << pair.second << std::endl;
		}
	}

	std::map<int, int> minimas;
	int limit = 1000;
	float default_load_factor = sherwood_map<int, int>().max_load_factor();
	for (int seed_modifier_stop = seed_modifier + 1000; seed_modifier < seed_modifier_stop; ++seed_modifier)
	{
		limit = limit * 3 / 2;
		for (size_t starting_index = 0; starting_index < detail::prime_list.size() && detail::prime_list[starting_index] < size_t(limit / 200); ++starting_index)
		{
			for (int i = 2; i < limit; i = i * 3 / 2)
			{
				minimas[i] = minimize_num_iterations(i, detail::prime_list[starting_index], default_load_factor);
			}
			auto min = std::min_element(costs.begin(), costs.end(), [](const auto & lhs, const auto & rhs)
			{
				return lhs.second.total_cost() < rhs.second.total_cost();
			});
			std::cout << detail::prime_list[starting_index] << " biggest saver: " << min->first << std::endl;
			std::map<double, int> total_costs;
			for (auto it = costs.begin(); it != costs.end(); ++it)
			{
				total_costs[it->second.total_cost()] = it->first;
			}
			for (auto it = total_costs.rbegin(); it != total_costs.rend(); ++it)
			{
				if (it->second > limit / 10)
					continue;
				std::cout << it->first << ": " << it->second << std::endl;
			}
		}
	}
	sherwood_map<int, int> a;
	{
		ScopedMeasurer measure_sherwood_map("sherwood_map");
		a = test_performance<sherwood_map<int, int> >(1000000, 5, default_load_factor);
	}
	std::unordered_map<int, int> b;
	{
		ScopedMeasurer measure_unordered_map("unordered_map");
		b = test_performance<std::unordered_map<int, int> >(1000000, 5, default_load_factor);
	}
	ASSERT_EQ(a.size(), b.size());
	for (auto it = b.begin(); it != b.end(); ++it)
	{
		auto found = a.find(it->first);
		ASSERT_NE(a.end(), found);
		ASSERT_EQ(it->second, found->second);
	}
}
#endif
}
#endif

