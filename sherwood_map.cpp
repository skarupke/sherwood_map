//#define PROFILE_SHERWOOD_MAP
#include "sherwood_map.hpp"
#include <stdexcept>

namespace detail
{
void throw_sherwood_map_out_of_range()
{
	throw std::out_of_range("out of range when trying to access a sherwood_map");
}

// prime numbers generated by the following method:
// 1. start with a prime p = 2
// 2. go to wolfram alpha and get p = NextPrime(2 * p)
// 3. repeat 2. until you overflow 64 bits
// you now have large gaps which you would hit if somebody called reserve() with an unlucky number.
// 4. to fill the gaps for every prime p go to wolfram alpha and get ClosestPrime(p * 2^(1/3)) and ClosestPrime(p * 2^(2/3)) and put those in the gaps
// 5. get PrevPrime(2^64) and put it at the end
#ifdef PROFILE_SHERWOOD_MAP
static std::vector<size_t> prime_list =
#else
static constexpr const size_t prime_list[] =
#endif
{
	2llu, 3llu, 5llu, 7llu, 11llu, 13llu, 17llu, 23llu, 29llu, 37llu, 47llu,
	59llu, 73llu, 97llu, 127llu, 151llu, 197llu, 251llu, 313llu, 397llu,
	499llu, 631llu, 797llu, 1009llu, 1259llu, 1597llu, 2011llu, 2539llu,
	3203llu, 4027llu, 5087llu, 6421llu, 8089llu, 10193llu, 12853llu, 16193llu,
	20399llu, 25717llu, 32401llu, 40823llu, 51437llu, 64811llu, 81649llu,
	102877llu, 129607llu, 163307llu, 205759llu, 259229llu, 326617llu,
	411527llu, 518509llu, 653267llu, 823117llu, 1037059llu, 1306601llu,
	1646237llu, 2074129llu, 2613229llu, 3292489llu, 4148279llu, 5226491llu,
	6584983llu, 8296553llu, 10453007llu, 13169977llu, 16593127llu, 20906033llu,
	26339969llu, 33186281llu, 41812097llu, 52679969llu, 66372617llu,
	83624237llu, 105359939llu, 132745199llu, 167248483llu, 210719881llu,
	265490441llu, 334496971llu, 421439783llu, 530980861llu, 668993977llu,
	842879579llu, 1061961721llu, 1337987929llu, 1685759167llu, 2123923447llu,
	2675975881llu, 3371518343llu, 4247846927llu, 5351951779llu, 6743036717llu,
	8495693897llu, 10703903591llu, 13486073473llu, 16991387857llu,
	21407807219llu, 26972146961llu, 33982775741llu, 42815614441llu,
	53944293929llu, 67965551447llu, 85631228929llu, 107888587883llu,
	135931102921llu, 171262457903llu, 215777175787llu, 271862205833llu,
	342524915839llu, 431554351609llu, 543724411781llu, 685049831731llu,
	863108703229llu, 1087448823553llu, 1370099663459llu, 1726217406467llu,
	2174897647073llu, 2740199326961llu, 3452434812973llu, 4349795294267llu,
	5480398654009llu, 6904869625999llu, 8699590588571llu, 10960797308051llu,
	13809739252051llu, 17399181177241llu, 21921594616111llu, 27619478504183llu,
	34798362354533llu, 43843189232363llu, 55238957008387llu, 69596724709081llu,
	87686378464759llu, 110477914016779llu, 139193449418173llu,
	175372756929481llu, 220955828033581llu, 278386898836457llu,
	350745513859007llu, 441911656067171llu, 556773797672909llu,
	701491027718027llu, 883823312134381llu, 1113547595345903llu,
	1402982055436147llu, 1767646624268779llu, 2227095190691797llu,
	2805964110872297llu, 3535293248537579llu, 4454190381383713llu,
	5611928221744609llu, 7070586497075177llu, 8908380762767489llu,
	11223856443489329llu, 14141172994150357llu, 17816761525534927llu,
	22447712886978529llu, 28282345988300791llu, 35633523051069991llu,
	44895425773957261llu, 56564691976601587llu, 71267046102139967llu,
	89790851547914507llu, 113129383953203213llu, 142534092204280003llu,
	179581703095829107llu, 226258767906406483llu, 285068184408560057llu,
	359163406191658253llu, 452517535812813007llu, 570136368817120201llu,
	718326812383316683llu, 905035071625626043llu, 1140272737634240411llu,
	1436653624766633509llu, 1810070143251252131llu, 2280545475268481167llu,
	2873307249533267101llu, 3620140286502504283llu, 4561090950536962147llu,
	5746614499066534157llu, 7240280573005008577llu, 9122181901073924329llu,
	11493228998133068689llu, 14480561146010017169llu, 18446744073709551557llu
};
size_t next_prime(size_t size)
{
	auto small_end = std::begin(prime_list) + 8;
	auto result = std::lower_bound(std::begin(prime_list), small_end, size);
	if (result == small_end) return *std::lower_bound(small_end, std::end(prime_list), size);
	else return *result;
}
}

#ifndef DISABLE_GTEST
#include <gtest/gtest.h>
static_assert(std::is_nothrow_move_constructible<sherwood_map<int, int> >::value, "expect it to be nothrow movable");
static_assert(std::is_nothrow_move_assignable<sherwood_map<int, int> >::value, "expect it to be nothrow movable");
namespace
{
struct IdentityHasher
{
	template<typename T>
	size_t operator()(T value) const
	{
		return value;
	}
};

template<typename T>
struct sherwood_test : ::testing::Test
{
};

TYPED_TEST_CASE_P(sherwood_test);

TYPED_TEST_P(sherwood_test, empty)
{
	typename TypeParam::template map<int, int> a;
	ASSERT_EQ(a.end(), a.find(5));
	ASSERT_TRUE(a.empty());
	a.emplace();
	a.clear();
	ASSERT_TRUE(a.empty());
}

TYPED_TEST_P(sherwood_test, simple)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a = { { 1, 5 }, { 2, 6 }, { 3, 7 } };
	ASSERT_EQ(3, a.size());
	a.insert(std::make_pair(1, 6));
	ASSERT_EQ(3, a.size());
	ASSERT_EQ(5, a[1]);
	ASSERT_EQ(6, a[2]);
	ASSERT_EQ(7, a[3]);
	ASSERT_EQ(0, a[4]);
	ASSERT_EQ(4, a.size());
	auto found = a.find(3);
	ASSERT_NE(a.end(), found);
	ASSERT_EQ(3, found->first);
	ASSERT_EQ(7, found->second);
	ASSERT_EQ(a.end(), a.find(5));

	ASSERT_EQ((map_type{ { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 0 } }), a);
}
TYPED_TEST_P(sherwood_test, move_construct)
{
	typedef typename TypeParam::template map<std::string, std::unique_ptr<int> > map_type;
	map_type a;
	a["foo"] = std::unique_ptr<int>(new int(5));
	ASSERT_EQ(5, *a["foo"]);
	float load_factor = a.max_load_factor() / 2;
	a.max_load_factor(load_factor);
	std::pair<std::string, std::unique_ptr<int> > to_insert("foo", std::unique_ptr<int>(new int(6)));
	a.emplace(std::move(to_insert));
	map_type b(std::move(a));
	ASSERT_EQ(1, b.size());
	ASSERT_EQ(0, a.size());
	ASSERT_EQ(5, *b["foo"]);
	ASSERT_EQ(load_factor, b.max_load_factor());
}
TYPED_TEST_P(sherwood_test, copy)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a{ { 1, 2 }, { 3, 4 }, { 5, 6 } };
	a.max_load_factor(a.max_load_factor() / 2);
	map_type b(a);
	ASSERT_EQ(a, b);
	ASSERT_EQ(a.max_load_factor(), b.max_load_factor());
}
TYPED_TEST_P(sherwood_test, erase)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a = { { 1, 2 }, { 3, 4 } };
	ASSERT_EQ(2, a.size());
	ASSERT_EQ(1, a.erase(3));
	ASSERT_EQ(1, a.size());
	ASSERT_EQ((map_type{ { 1, 2 } }), a);
}
TYPED_TEST_P(sherwood_test, iterator_erase)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };
	auto begin = a.erase(a.begin(), std::next(a.begin(), 2));
	ASSERT_EQ(a.begin(), begin);
	ASSERT_EQ(*a.begin(), *begin);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	ASSERT_EQ(*a.begin(), *begin);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.end(), begin);
	ASSERT_TRUE(a.empty());
}
TYPED_TEST_P(sherwood_test, conflicting_iterator_erase)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.reserve(5);
	a.insert({ { 1, 2 }, { 6, 5 }, { 11, 8 }, { 16, 11 } });
	auto begin = a.erase(a.begin(), std::next(a.begin(), 2));
	ASSERT_EQ(a.begin(), begin);
	ASSERT_EQ(*a.begin(), *begin);
	ASSERT_EQ((map_type{ { 11, 8 }, { 16, 11 } }), a);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	ASSERT_EQ(*a.begin(), *begin);
	ASSERT_EQ((map_type{ { 16, 11 } }), a);
	begin = a.erase(a.begin());
	ASSERT_EQ(a.end(), begin);
	ASSERT_TRUE(a.empty());
}
TYPED_TEST_P(sherwood_test, two_conflicting_iterator_erase)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.reserve(5);
	a.insert({ { 1, 2 }, { 6, 5 }, { 4, 8 }, { 9, 11 }, { 14, 14 } });
	auto begin = a.erase(a.begin());
	ASSERT_EQ(a.begin(), begin);
	ASSERT_EQ(a.begin(), a.find(a.begin()->first));
	ASSERT_EQ((map_type{ { 1, 2 }, { 6, 5 }, { 4, 8 }, { 14, 14 } }), a);
}

TYPED_TEST_P(sherwood_test, conflicting_iterator_erase_middle)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.reserve(5);
	a.insert({ { 1, 2 }, { 6, 5 }, { 11, 8 }, { 16, 11 } });
	a.erase(std::next(a.begin()));
	ASSERT_EQ((map_type{ { 1, 2 }, { 11, 8 }, { 16, 11 } }), a);
}
TYPED_TEST_P(sherwood_test, erase_conflicting_with_non_conflicting)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.rehash(5);
	// the idea is this: you will end up with elements in this
	// order as they are here. then we erase the first two.
	// element 11 has to move over by two, element 3 only has to
	// move over by one
	a.insert({ { 1, 2 }, { 6, 5 }, { 11, 8 }, { 3, 9 } });
	a.erase(a.begin(), std::next(a.begin(), 2));
	ASSERT_EQ((map_type{ { 3, 9 }, { 11, 8 } }), a);
}
TYPED_TEST_P(sherwood_test, range_erase)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a{ { 1, 5 }, { 2, 6 }, { 3, 7 }, { 4, 0 } };
	a.erase(std::next(a.begin()), a.end());
	ASSERT_EQ(1, a.size());
	a.erase(a.begin(), a.end());
	ASSERT_TRUE(a.empty());
}
TYPED_TEST_P(sherwood_test, erase_all)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.rehash(3);
	a.insert({ { 1, 5 }, { 2, 6 }, { 3, 7 } });
	ASSERT_EQ(a.end(), a.erase(a.begin(), a.end()));
	ASSERT_TRUE(a.empty());
	ASSERT_EQ(a.end(), a.begin());
}
TYPED_TEST_P(sherwood_test, move_over_please)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.rehash(5);
	// the idea is this: 1 and 2 go to their spots. 5 goes to 0,
	// 10 can't go to 0 so goes to 1 and pushes 1 and 2 over,
	// 15 does the same thing
	a.insert({ { 1, 5 }, { 2, 6 }, { 5, 7 }, { 10, 8 }, { 15, 9 } });
	ASSERT_EQ((map_type{ { 1, 5 }, { 2, 6 }, { 5, 7 }, { 10, 8 }, { 15, 9 } }), a);
}
TYPED_TEST_P(sherwood_test, emplace_hint)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a = { { 1, 2 }, { 3, 4 } };
	auto found = a.find(1);
	ASSERT_NE(a.end(), found);
	auto insert_point = a.erase(found);
	a.insert(insert_point, std::make_pair(1, 3));
	ASSERT_EQ((map_type{ { 1, 3 }, { 3, 4 } }), a);
}

TYPED_TEST_P(sherwood_test, special_value)
{
	size_t special_value = detail::empty_hash;
	typedef typename TypeParam::template map<size_t, int, IdentityHasher> map_type;
	map_type a = { { special_value, 1 }, { special_value + 1, 2 } };
	ASSERT_EQ(2, a.size());
	ASSERT_EQ(1, a[special_value]);
	ASSERT_EQ(2, a[special_value + 1]);
}
TYPED_TEST_P(sherwood_test, crowded_end)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	// test whether erase will correctly shift elements from the beginning
	// of the storage to the end of the storage when erasing near the end
	map_type a;
	a.rehash(31);
	ASSERT_EQ(31, a.bucket_count()); // need to be my amount for this test to make sense
	a[28] = 5;
	a[59] = 6;
	a[90] = 7;
	a[121] = 8;
	a[152] = 9;
	a[183] = 10;
	a[214] = 11;
	ASSERT_EQ(31, a.bucket_count()); // reallocation would mess up my test
	ASSERT_EQ(121, a.begin()->first); // assume 28 goes to 28, 59 goes to 29, 90 goes to 30, 121 goes to 0
	ASSERT_EQ((map_type{ { 28, 5 }, { 59, 6 }, { 90, 7 }, { 121, 8 }, { 152, 9, }, { 183, 10 }, { 214, 11 } }), a);
	a.erase(28);
	ASSERT_EQ((map_type{ { 59, 6 }, { 90, 7 }, { 121, 8 }, { 152, 9, }, { 183, 10 }, { 214, 11 } }), a);
	// had a bug where elements remained and weren't markes as deleted properly
	ASSERT_EQ(a.size(), std::distance(a.begin(), a.end()));
}
TYPED_TEST_P(sherwood_test, swap)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a = { { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 } };
	a.max_load_factor(0.5f);
	map_type b = { { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 } };
	b.max_load_factor(0.6f);
	a.swap(b);
	ASSERT_EQ((map_type{ { 1, 1 }, { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 } }), b);
	ASSERT_EQ(5, b.size());
	ASSERT_EQ(0.5f, b.max_load_factor());
	ASSERT_EQ((map_type{ { 2, 2 }, { 3, 3 }, { 4, 4 }, { 5, 5 }, { 6, 6 }, { 7, 7 } }), a);
	ASSERT_EQ(6, a.size());
	ASSERT_EQ(0.6f, a.max_load_factor());
}
struct CtorDtorCounter
{
	CtorDtorCounter(int & ctor_counter, int & dtor_counter)
		: ctor_counter(ctor_counter), dtor_counter(dtor_counter)
	{
		++ctor_counter;
	}
	CtorDtorCounter(const CtorDtorCounter & other)
		: ctor_counter(other.ctor_counter), dtor_counter(other.dtor_counter)
	{
		++ctor_counter;
	}
	CtorDtorCounter & operator=(const CtorDtorCounter &)
	{
		return *this;
	}
	~CtorDtorCounter()
	{
		++dtor_counter;
	}

private:
	int & ctor_counter;
	int & dtor_counter;
};
static size_t construction_counter = 0;
static size_t destruction_counter = 0;
static size_t num_allocations = 0;
static size_t num_frees = 0;
template<typename T>
struct CountingAllocator
{
	CountingAllocator() = default;
	template<typename U>
	CountingAllocator(CountingAllocator<U>)
	{
	}

	typedef T value_type;
	template<typename U>
	struct rebind
	{
		typedef CountingAllocator<U> other;
	};

	T * allocate(size_t n, const void * = nullptr)
	{
		++num_allocations;
		return static_cast<T *>(malloc(sizeof(T) * n));
	}
	void deallocate(T * ptr, size_t)
	{
		++num_frees;
		return free(ptr);
	}
	template<typename U, typename... Args>
	void construct(U * ptr, Args &&... args)
	{
		new (ptr) U(std::forward<Args>(args)...);
		++construction_counter;
	}
	template<typename U>
	void destroy(U * ptr)
	{
		++destruction_counter;
		ptr->~U();
	}
};
struct ScopedAssertNoLeaks
{
	ScopedAssertNoLeaks(bool expect_allocations, bool expect_constructions)
		: expect_allocations(expect_allocations)
		, expect_constructions(expect_constructions)
		, constructions_before(construction_counter)
		, destructions_before(destruction_counter)
		, allocations_before(num_allocations)
		, frees_before(num_frees)
	{
	}
	~ScopedAssertNoLeaks()
	{
		run_asserts();
	}

private:
	bool expect_allocations;
	bool expect_constructions;
	size_t constructions_before;
	size_t destructions_before;
	size_t allocations_before;
	size_t frees_before;

	void run_asserts()
	{
		if (expect_allocations)
		{
			ASSERT_NE(num_allocations, allocations_before);
		}
		if (expect_constructions)
		{
			ASSERT_NE(construction_counter, constructions_before);
		}
		ASSERT_EQ(construction_counter - constructions_before, destruction_counter - destructions_before);
		ASSERT_EQ(num_allocations - allocations_before, num_frees - frees_before);
	}
};
TYPED_TEST_P(sherwood_test, destructor_caller)
{
	typedef typename TypeParam::template map<int, CtorDtorCounter, std::hash<int>, std::equal_to<int>, CountingAllocator<std::pair<int, CtorDtorCounter> > > map_type;
	ScopedAssertNoLeaks leak_check(true, true);
	int ctor_counter = 0;
	int dtor_counter = 0;
	{
		map_type a;
		for (int i = 0; i < 4; ++i)
		{
			a.emplace(i, CtorDtorCounter(ctor_counter, dtor_counter));
		}
		a.erase(5);
		a.erase(a.begin(), std::next(a.begin(), 3));
	}
	ASSERT_NE(0, ctor_counter);
	ASSERT_EQ(ctor_counter, dtor_counter);
}
struct throwing_allocator_exception {};
template<typename T>
struct throwing_allocator : CountingAllocator<T>
{
	throwing_allocator() = default;
	template<typename U>
	throwing_allocator(const throwing_allocator<U> &)
	{
	}

	template<typename U>
	struct rebind
	{
		typedef throwing_allocator<U> other;
	};

	template<typename U, typename... Args>
	void construct(U *, Args &&...)
	{
		throw throwing_allocator_exception{};
	}
};

TYPED_TEST_P(sherwood_test, throwing_allocator_test)
{
	ScopedAssertNoLeaks leak_check(true, false);
	auto construct = []{ typename TypeParam::template map<int, int, std::hash<int>, std::equal_to<int>, throwing_allocator<std::pair<const int, int> > >{ { 1, 2 }, { 2, 3 } }; };
	ASSERT_THROW(construct(), throwing_allocator_exception);
}

struct stateful_hasher
{
	stateful_hasher() = default;
	stateful_hasher(const stateful_hasher & other)
		: to_add(other.to_add + 1)
	{
	}
	stateful_hasher(stateful_hasher &&) = default;
	stateful_hasher & operator=(const stateful_hasher & other)
	{
		to_add = other.to_add + 1;
		return *this;
	}
	stateful_hasher & operator=(stateful_hasher &&) = default;

	template<typename T>
	size_t operator()(const T & value) const
	{
		return std::hash<T>()(value) + to_add;
	}

	size_t to_add = 0;
};

TYPED_TEST_P(sherwood_test, stateful_hasher_test)
{
	typedef typename TypeParam::template map<int, int, stateful_hasher> map_type;
	map_type a{ { 1, 2 }, { 3, 4 }, { 5, 7 }, { 8, 9 } };
	a = a;
	ASSERT_EQ((map_type{ { 1, 2 }, { 3, 4 }, { 5, 7 }, { 8, 9 } }), a);
}

TYPED_TEST_P(sherwood_test, load_factor)
{
	typename TypeParam::template map<int, int> a;
	ASSERT_EQ(0, a.load_factor());
}
TYPED_TEST_P(sherwood_test, max_load_factor)
{
	typedef typename TypeParam::template map<int, int> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.insert({ { 1, 2 }, { 2, 3 }, { 3, 4 } });
	ASSERT_EQ((map_type{ { 1, 2 }, { 2, 3 }, { 3, 4 } }), a);
}
TYPED_TEST_P(sherwood_test, dont_grow_when_you_wont_insert)
{
	typename TypeParam::template map<int, int> a;
	a.max_load_factor(1.0f);
	a.reserve(3);
	size_t bucket_count_before = a.bucket_count();
	a.insert({ { 1, 2 }, { 3, 4 }, { 5, 6 }, { 5, 6 } });
	ASSERT_EQ(bucket_count_before, a.bucket_count());
}
TYPED_TEST_P(sherwood_test, allow_growing_with_max_load_factor_1)
{
	typedef typename TypeParam::template map<int, int, IdentityHasher> map_type;
	map_type a;
	a.max_load_factor(1.0f);
	a.reserve(3);
	a.insert({ { 1, 2 }, { 4, 4 }, { 7, 6 }, { 10, 8 } });
	ASSERT_EQ((map_type{ { 1, 2 }, { 4, 4 }, { 7, 6 }, { 10, 8 } }), a);
}

}
#include <random>
#include <unordered_map>
#include <map>
#include <chrono>
#include <fstream>
namespace
{
template<typename T>
struct insert_performance
{
	T operator()(int amount, int seed, float /*load_factor*/) const __attribute__((noinline))
	{
		T hash_map;
		std::mt19937 engine(seed);
		std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
		for (int i = 0; i < amount; ++i)
		{
			hash_map[i] = distribution(engine);
		}
		return hash_map;
	}
};
template<typename T>
struct insert_performance_reserve
{
	T operator()(int amount, int seed, float load_factor) const __attribute__((noinline))
	{
		T hash_map;
		hash_map.max_load_factor(load_factor);
		hash_map.reserve(amount);
		size_t bucket_count = hash_map.bucket_count();
		std::mt19937 engine(seed);
		std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
		for (int i = 0; i < amount; ++i)
		{
			hash_map[i] = distribution(engine);
		}
		if (hash_map.bucket_count() != bucket_count)
		{
			throw std::runtime_error("the hash map reallocated, which isn't intended because I want to test for a certain load factor");
		}
		return hash_map;
	}
};

template<typename T>
struct modify_performance
{
	T operator()(int amount, int seed, float load_factor) const __attribute__((noinline))
	{
		T hash_map;
		hash_map.max_load_factor(load_factor);
		hash_map.reserve(amount);
		size_t bucket_count = hash_map.bucket_count();
		std::mt19937 engine(seed);
		std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
		std::vector<int> all_keys;
		for (int i = 0; i < amount; ++i)
		{
			all_keys.push_back(distribution(engine));
			hash_map[all_keys.back()] = i;
		}
		for (size_t i = 0; i < all_keys.size(); ++i)
		{
			auto found = hash_map.find(all_keys[i]);
			if (found != hash_map.end()) hash_map.erase(found);
			hash_map[distribution(engine)] = distribution(engine);
		}
		if (hash_map.bucket_count() != bucket_count)
		{
			throw std::runtime_error("the hash map reallocated, which isn't intended because I want to test for a certain load factor");
		}
		return hash_map;
	}
};
template<typename T>
struct erase_performance
{
	T operator()(int amount, int seed, float load_factor) const __attribute__((noinline))
	{
		T hash_map;
		hash_map.max_load_factor(load_factor);
		hash_map.reserve(amount);
		size_t bucket_count = hash_map.bucket_count();
		std::mt19937 engine(seed);
		std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
		std::vector<int> all_keys;
		for (int i = 0; i < amount; ++i)
		{
			all_keys.push_back(distribution(engine));
			hash_map[all_keys.back()] = i;
		}
		if (hash_map.bucket_count() != bucket_count)
		{
			throw std::runtime_error("the hash map reallocated, which isn't intended because I want to test for a certain load factor");
		}
		for (int key : all_keys)
		{
			hash_map.erase(key);
		}
		return hash_map;
	}
};
template<typename T>
struct performance_lookups
{
	T operator()(int amount, int seed, float load_factor) const __attribute__((noinline))
	{
		T hash_map;
		hash_map.max_load_factor(load_factor);
		hash_map.reserve(amount);
		size_t bucket_count = hash_map.bucket_count();
		std::mt19937 engine(seed);
		std::uniform_int_distribution<int> distribution(0, std::numeric_limits<int>::max());
		hash_map.reserve(amount);
		for (int i = 0; i < amount; ++i)
		{
			hash_map[distribution(engine)] = i;
		}
		if (hash_map.bucket_count() != bucket_count)
		{
			throw std::runtime_error("the hash map reallocated, which isn't intended because I want to test for a certain load factor");
		}
		std::vector<unsigned char> results;
		results.reserve(amount * 20);
		for (int i = 0; i < amount * 20; ++i)
		{
			results.push_back(hash_map.find(i) == hash_map.end());
		}
		return hash_map;
	}
};
constexpr int profile_amount = 1000000;
struct LargeStruct
{
	LargeStruct()
		: a(0)
	{
	}
	LargeStruct(int a)
		: a(a)
	{
	}
	int a;
	char unused[120];
};
struct MediumStruct
{
	MediumStruct() = default;
	MediumStruct(int i)
		: i(i), a()
	{
	}
	int i;
	std::string a;
	bool operator==(const MediumStruct & other) const
	{
		return i == other.i && a == other.a;
	}
};
}
namespace std
{
template<>
struct hash<MediumStruct>
{
	size_t operator()(const MediumStruct & obj) const
	{
		return obj.i;
	}
};
}
namespace
{
struct Measurer
{
	Measurer()
		: before(std::chrono::high_resolution_clock::now())
	{
	}
	std::chrono::milliseconds duration()
	{
		return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::high_resolution_clock::now() - before);
	}

	std::chrono::high_resolution_clock::time_point before;
};

template<typename T>
void profile_single(std::ostream & out, const char * category, const char * name, int amount, int seed, float load_factor)
{
	Measurer measure;
	T()(amount, seed, load_factor);
	auto duration = measure.duration();
	out << category << " " << name << ": " << duration.count() << "\n";
}

template<template<typename> class Profile>
void profile(const char * name, int amount, int seed, float load_factor)
{
	std::ofstream out("performance_stats", std::ios_base::app);
	profile_single<Profile<std::unordered_map<int, int> > >(out, "unordered small", name, amount, seed, load_factor);
	profile_single<Profile<sherwood_map<int, int> > >(out, "sherwood small", name, amount, seed, load_factor);
	profile_single<Profile<fat_sherwood_map<int, int> > >(out, "fat_sherwood small", name, amount, seed, load_factor);
	profile_single<Profile<std::unordered_map<MediumStruct, MediumStruct> > >(out, "unordered medium", name, amount, seed, load_factor);
	profile_single<Profile<sherwood_map<MediumStruct, MediumStruct> > >(out, "sherwood medium", name, amount, seed, load_factor);
	profile_single<Profile<fat_sherwood_map<MediumStruct, MediumStruct> > >(out, "fat_sherwood medium", name, amount, seed, load_factor);
	profile_single<Profile<std::unordered_map<int, LargeStruct> > >(out, "unordered large", name, amount, seed, load_factor);
	profile_single<Profile<sherwood_map<int, LargeStruct> > >(out, "sherwood large", name, amount, seed, load_factor);
	profile_single<Profile<fat_sherwood_map<int, LargeStruct> > >(out, "fat_sherwood large", name, amount, seed, load_factor);
}
constexpr int profile_repetition_count = 10;
static float profile_load_factor = sherwood_map<int, int>().max_load_factor();
TEST(sherwood_map, DISABLED_profile_insertion)
{
	for (int i = 0; i < profile_repetition_count; ++i) profile<insert_performance>("insert", profile_amount, 5, profile_load_factor);
}
TEST(sherwood_map, DISABLED_profile_insertion_reserve)
{
	for (int i = 0; i < profile_repetition_count; ++i) profile<insert_performance_reserve>("insert_reserve", profile_amount, 5, profile_load_factor);
}
TEST(sherwood_map, DISABLED_profile_modify)
{
	for (int i = 0; i < profile_repetition_count; ++i) profile<modify_performance>("modify", profile_amount / 2, 6, profile_load_factor);
}
TEST(sherwood_map, DISABLED_profile_lookup)
{
	for (int i = 0; i < profile_repetition_count; ++i) profile<performance_lookups>("lookups", profile_amount / 5, 7, profile_load_factor);
}
TEST(sherwood_map, DISABLED_profile_erase)
{
	for (int i = 0; i < profile_repetition_count; ++i) profile<erase_performance>("erase", profile_amount / 2, 8, profile_load_factor);
}

TEST(sherwood_map, DISABLED_profile_first_insert)
{
	for (int i = 0; i < 1000000; ++i)
	{
		sherwood_map<int, int> a;
		a.emplace(1, 1);
	}
}

#if 0
TEST(sherwood_map, performance)
{
	{
		std::map<float, double> load_factor_costs;
		for (float load_factor = 0.7f;; load_factor = std::min(1.0f, load_factor + 0.01f))
		{
			int limit = 1000;
			ScopedMeasurer measure("load_factor");
			size_t allocated_before = mem::MemoryManager::GetTotalBytesAllocated();
			double total_cost = 0.0;
			for (int starting_value = 0; starting_value < 3; starting_value += 2)
			{
				for (int i = 2; i < limit; i = i * 3 / 2)
				{
					total_cost += run_performance_test(i, starting_value, load_factor);
				}
			}
			load_factor_costs[load_factor] = total_cost;
			std::cout << load_factor << ": " << (mem::MemoryManager::GetTotalBytesAllocated() - allocated_before) << ", " << total_cost << ", ";
			if (load_factor == 1.0f)
				break;
		}
		std::map<size_t, float> sorted_load_factor_costs;
		for (const auto & pair : load_factor_costs)
		{
			sorted_load_factor_costs[pair.second] = pair.first;
		}
		for (const auto & pair : sorted_load_factor_costs)
		{
			std::cout << pair.first << ": " << pair.second << std::endl;
		}
	}
}
#endif
struct sherwood_map_tester
{
	template<typename K, typename V, typename H = std::hash<K>, typename E = std::equal_to<K>, typename A = std::allocator<std::pair<K, V> > >
	using map = sherwood_map<K, V, H, E, A>;
};
struct fat_sherwood_map_tester
{
	template<typename K, typename V, typename H = std::hash<K>, typename E = std::equal_to<K>, typename A = std::allocator<std::pair<K, V> > >
	using map = fat_sherwood_map<K, V, H, E, A>;
};
REGISTER_TYPED_TEST_CASE_P(sherwood_test, empty, simple, move_construct, copy, erase, iterator_erase, conflicting_iterator_erase, range_erase, move_over_please, emplace_hint, special_value, crowded_end, swap, destructor_caller, throwing_allocator_test, stateful_hasher_test, load_factor, max_load_factor, dont_grow_when_you_wont_insert, allow_growing_with_max_load_factor_1, erase_conflicting_with_non_conflicting, conflicting_iterator_erase_middle, two_conflicting_iterator_erase, erase_all);
INSTANTIATE_TYPED_TEST_CASE_P(sherwood_map, sherwood_test, sherwood_map_tester);
INSTANTIATE_TYPED_TEST_CASE_P(fat_sherwood_map, sherwood_test, fat_sherwood_map_tester);
}
#endif

